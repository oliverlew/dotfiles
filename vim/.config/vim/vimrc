" Vim or NeoVim? {{{
if !has("nvim")
    so $XDG_CONFIG_HOME/vim/vim.vimrc
else
    luafile $XDG_CONFIG_HOME/nvim/init.lua
endif
" }}}
" Vim basic config {{{
" leader key, for key mappings
let mapleader = ','
let maplocalleader = '\'
" detect filetype and apply syntax highlighting
syntax on
filetype on
filetype plugin on
filetype indent on
set backup " create back files
set autoread " auto reload files
set autowrite " automatically write a file when leaving a buffer
set hidden
set encoding=utf-8
set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1
set spelllang=en,cjk " spell check but exclude CJK language
set clipboard=unnamedplus " use x11 normal clipboard
set timeoutlen=300 " time out for key code delays
set ttimeoutlen=0 " do not wait after escape key
set diffopt+=vertical " open diff window vertically
set nrformats+=alpha " use Ctrl-A/X to in/decrease alphabets
set completeopt=menu,preview " completion
set formatoptions+=mM " better multibyte (CJK) support
set incsearch ignorecase smartcase hlsearch
" }}}
" UI basic {{{
set guioptions=di       " gui options: dark, icon
set number              " show line number
set relativenumber      " show relative number
set showcmd             " shows what you are typing as a command
set wildmenu            " turn on wild menu on :e <Tab>
set title               " change the terminal's title
set showmatch           " show matching characters
set scrolloff=5         " minimum lines above and below cursor
set splitright          " split into right by default
set splitbelow          " split to below by default
set updatetime=100      " update time, related to fugitive sign column update, etc.
set signcolumn=yes      " always show sign column
set lazyredraw          " redraw when needed
set noerrorbells        " don't beep
set shortmess+=I        " don't show welcome screen
set showtabline=2       " show tabs on top
set laststatus=2        " show status line
set noshowmode          " do not show mode on the last line
set display+=lastline   " show partial line
set background=dark     " color scheme
set mouse=a             " enable mouse support in console
" cursor shape for terminal emulators or linux console
if has("gui_running") == 0
    if $TERM != "linux"
        let &t_SI = "\e[6 q"
        let &t_SR = "\e[4 q"
        let &t_EI = "\e[2 q"
    else
        let &t_ve = "\e[?25h"
        let &t_vi = "\e[?25l"
        let &t_SI = "\e[?0c"
        let &t_SR = "\e[?4c"
        let &t_EI = "\e[?8c"
    endif
endif
" color scheme
hi SignColumn   ctermbg=None ctermfg=0
hi CursorColumn ctermbg=0
hi ColorColumn  ctermbg=0
hi Folded       ctermbg=None ctermfg=8
hi NonText      ctermbg=None ctermfg=8
hi SpellBad     ctermbg=None ctermfg=9
hi SpellCap     ctermbg=None ctermfg=11
hi Visual       ctermbg=None             cterm=reverse
hi VertSplit    ctermbg=None ctermfg=7   cterm=None
" popup menu
hi Pmenu        ctermbg=0    ctermfg=7
hi PmenuSel     ctermbg=None ctermfg=6   cterm=None
" status line
hi StatusLine   ctermbg=None ctermfg=7
hi StatusLineNC ctermbg=None ctermfg=7
" tab line
hi TabLine      ctermbg=None ctermfg=7   cterm=None
hi TabLineSel   ctermbg=6    ctermfg=0   cterm=None
hi TabLineFill  ctermbg=None ctermfg=7   cterm=None
" symbol hightlight
hi IlluminatedWordText  ctermbg=8
hi IlluminatedWordRead  ctermbg=8
hi IlluminatedWordWrite ctermbg=8
" }}}
" built-in plugins or file type supports {{{
let g:termdebug_wide=1
let g:markdown_folding = 1
let g:markdown_fenced_languages = ['html', 'python', 'bash=sh', 'sh', 'c']
" }}}
" Space Tabs Indentations {{{
" indentations
set autoindent
set smartindent
" tabs
set tabstop=4
set shiftwidth=0  " make it the same as tabstop
set softtabstop=-1  " make it the same as shiftwidth
set expandtab       " change tab to spaces
set smarttab
" show tabs and trailing white space
set list
set listchars=tab:>-,trail:.
" }}}
" Navigations {{{
" go up/down in one wrapped long line
nnoremap <silent> j gj
nnoremap <silent> k gk
vnoremap <silent> j gj
vnoremap <silent> k gk
" buffers
nnoremap <silent> <C-K> :bprevious<CR>
nnoremap <silent> <C-J> :bnext<CR>
nnoremap <silent> <C-P> :cprevious<CR>
nnoremap <silent> <C-N> :cnext<CR>
nnoremap <silent> [l :lprevious<CR>
nnoremap <silent> ]l :lnext<CR>
" toggle fold
nnoremap <space> za
" center the screen when searching
" n/N: search, zz: center, zv: unfold
nnoremap n nzzzv
nnoremap N Nzzzv
" some simple key bindings
noremap <leader>q :q<CR>
noremap <leader>Q :qa<CR>
noremap <leader>d :bd<CR>
noremap <leader>w :w<CR>
noremap <leader>e :e<CR>
noremap <leader>x :x<CR>
noremap <leader>k :call ExecCurrentFile()<CR>
noremap <leader>r :so $MYVIMRC<CR>
noremap <leader>z :call Goyo()<CR>
" }}}
" Autocmd {{{
augroup normal
    autocmd!
    " make sure the cursor reset to block shape, see the cursor shape settings
    autocmd VimEnter * normal! :startinsert :stopinsert
    " some file types
    autocmd BufNewFile,BufRead *.mac setlocal ft=maxima
    autocmd BufNewFile,BufRead *.plt setlocal ft=gnuplot
    autocmd BufNewFile,BufRead *.muttrc setlocal ft=muttrc
    " load Xresources on save
    autocmd BufWritePost Xresources,*Xresources call system("xrdb -load ".expand('%'))
    " tabs for these file types
    autocmd FileType tex,markdown,mma setlocal sw=2 ts=2 sts=2 cole=0
    autocmd FileType c,cpp,mma,json setlocal noet
    " spell check for these file types
    autocmd FileType tex,markdown,gitcommit setlocal spell
    autocmd FileType markdown setlocal foldlevel=1
    " comment strings for vim-commentary
    autocmd FileType gnuplot setlocal commentstring=#%s
    autocmd FileType maxima setlocal commentstring=/*%s*/
    autocmd FileType mma setlocal commentstring=(*%s*)
    " wrap lines even in diff
    autocmd VimEnter * if &diff | execute 'windo set wrap' | endif
augroup END
augroup terminal_setup
    autocmd!
    tnoremap <C-\> <C-\><C-N>
    if has('nvim')
        autocmd TermOpen term://* setlocal nonu nornu signcolumn=no  " no left columns
        autocmd TermOpen term://* startinsert  " no need to 'I' into command line
        autocmd TermClose term://* call feedkeys("\<CR>")  " no need to 'Enter' to exit
    elseif exists("##TerminalOpen")
        autocmd TerminalOpen * setlocal nonu nornu signcolumn=no
    endif
augroup END
augroup latex
    autocmd!
    " add normal font in math
    autocmd FileType tex xnoremap <localleader>n s\mathrm{}<Esc>P
    autocmd FileType tex nnoremap <localleader>n a\mathrm{}<Left>
    " add red color, or to existing text
    autocmd FileType tex xnoremap <localleader>m s{\color{red}}<Esc>P
    autocmd FileType tex nnoremap <localleader>m a{\color{red}}<Left>
    " remove red color depends on vim-surround
    autocmd FileType tex nnoremap <localleader>d F{mr%x`rd12l
augroup END
augroup makeprg
    autocmd!
    autocmd Filetype sh compiler shellcheck
    autocmd Filetype perl compiler perl
    autocmd Filetype tex compiler tex | let &makeprg = "latexmk -xelatex -interaction=nonstopmode %"
    autocmd BufWrite tex exe 'Make'
augroup END
" }}}
" IM Toggle {{{
" restore input method state when enter insert mode
function CheckFcitxCmd()
    if !exists("s:fcitx_cmd")
        let s:find_exe = "command -v fcitx-remote || command -v fcitx5-remote"
        let s:fcitx_cmd = trim(system(s:find_exe))
    endif
endfunction
function IMDisable()
    call CheckFcitxCmd()
    if !exists("s:fcitxon")
        let s:fcitxon = system(s:fcitx_cmd) =~ '^\d'
    endif
    if s:fcitxon
        let b:fcitx = system(s:fcitx_cmd)
        call system(s:fcitx_cmd . ' -c')
    endif
endfunction
function IMEnable()
    call CheckFcitxCmd()
    if exists('b:fcitx') && b:fcitx == 2
        call system(s:fcitx_cmd . ' -o')
    endif
endfunction
augroup im_toggle
    autocmd!
    autocmd InsertLeave * call IMDisable()
    autocmd InsertEnter * call IMEnable()
augroup END
" }}}
" Netrw {{{
" Make Netrw function like NerdTree
let g:netrw_home         = $XDG_DATA_HOME.'/vim'
let g:netrw_banner       = 0    " disable banner (help message, etc. at top)
let g:netrw_browse_split = 4    " open file in previous (CTRL-W_p) window
let g:netrw_winsize      = -20  " split size, minus meaning absolute size
let g:netrw_dirhistmax   = 0    " disable history
let g:netrw_liststyle    = 0    " one file per line with nothing else
nnoremap L :silent Lexplore<CR>
augroup NetrwKeys
    autocmd!
    autocmd Filetype netrw nmap <buffer> h <Plug>NetrwBrowseUpDir
    autocmd Filetype netrw nmap <buffer> l <Plug>NetrwLocalBrowseCheck
augroup END
" }}}
" My own goyo mode {{{
function Goyo()
    if exists("g:goyo_status")
        unlet g:goyo_status
        set nu rnu ru scl=auto stal=2 ls=2
    else
        let g:goyo_status = 1
        set nonu nornu noru scl=no stal=0 ls=0
    endif
endfunction
" }}}
" Execute current file {{{
function ShowOutput(channel, msg)
    if bufwinnr("exec_out") == -1
        sbuffer exec_out
    endif
endfunction

function AsyncRun(cmd)
    if bufexists("exec_out")
        call deletebufline("exec_out", 1, '$')
    endif
    call job_start(a:cmd, {
    \   "out_io": "buffer",
    \   "err_io": "buffer",
    \   "out_name": "exec_out",
    \   "err_name": "exec_out",
    \   "callback": function('ShowOutput'),
    \ })
endfunction

function ExecCurrentFile()
    if index(['gnuplot', 'perl', 'python', 'sh'], &ft) >= 0
        let command = [&ft, expand("%:p")]
    elseif &ft == "maxima"
        let command = ["maxima", "-b", expand("%:p")]
    elseif &ft == "tex"
        let command = ["latexmk", "-xelatex", "-pvc", expand("%:p")]
    else
        if &ft == "markdown"
            call MarkdownPreviewToggle()
        else
            echo "Not supported file type"
        endif
        return
    endif
    call AsyncRun(command)
endfunction

function Make()
    let makefile = findfile("Makefile", ".;")
    call AsyncRun(["make", "-C", makefile])
endfunction
" }}}
" statusline {{{
" update status on LSP status changes
function! LSPStatus()
    if has('nvim')
        return luaeval('NvimLSPStatus()')
    elseif exists('*lsp#get_buffer_diagnostics_counts')
        let l:counts = lsp#get_buffer_diagnostics_counts()
        let l:lsp_status  = l:counts.error == 0 ? '' : printf('E:%2d ', l:counts.error)
        let l:lsp_status .= l:counts.warning == 0 ? '' : printf('W:%2d ', l:counts.warning)
        let l:lsp_status .= l:counts.information == 0 ? '' : printf('I:%2d ', l:counts.information)
        let l:lsp_status .= l:counts.hint == 0 ? '' : printf('H:%2d ', l:counts.hint)
        let l:lsp_status .= l:lsp_status == '' ? 'OK ' : ''
        return ' ' . l:lsp_status
    else
        return ""
    endif
endfunction
function GitBranch()
    let cmd = 'git -C '.expand("%:h:S").' branch --show-current 2>/dev/null'
    silent return trim(system(cmd))
endfunction
hi User1 ctermbg=0
hi User2 ctermbg=8
hi User3 ctermfg=0 ctermbg=6

augroup UpdateStatus
  autocmd!
  autocmd User lsp_diagnostics_updated redrawstatus
augroup END
" NOTE: keep the spaces in the %(%) group
let stl1 = ' %{mode()} '                          " vim modes
let stl2 = '%(%( %{GitBranch()}%)%( %r%h%) %)'    " git branch, readonly, help
let stl3 = '%< %t %m %w '                         " file name, modified, preview
let stl4 = '%{&ff} %(| %{&fenc} %)%(| %{&ft} %)'  " format, encoding and type
let stl5 = ' %p%% | %l:%c '                       " cursor location
let stl6 = ' %{LSPStatus()} '                     " lsp status
let &stl = '%3*'.stl1.'%2*'.stl2.'%1*'.stl3.'%='.stl4.'%2*'.stl5.'%3*'.stl6.'%*'
" }}}
" Git {{{
" show the log in a pretty way
function! GitLog()
    silent !git -C "$(dirname "$(realpath "%")")" log --all --decorate --oneline --graph --date-order
    redraw!
endfunction
function! GitTig()
    silent !tig -C "$(dirname "$(realpath "%")")"
    redraw!
endfunction
" key bindings
nnoremap <leader>gg :call GitTig()<CR>
nnoremap <leader>gl :call GitLog()<CR>
" }}}
" Markdown preview{{{
function MarkdownPreviewToggle()
    if !exists('b:mdp_job')
        if has('nvim')
            let b:mdp_job = jobstart(['grip', '-b', expand("%:p")])
        else
            let b:mdp_job = job_start(['grip', '-b', expand("%:p")])
        endif
    else
        if has('nvim')
            call jobstop(b:mdp_job)
        else
            call job_stop(b:mdp_job)
        endif
        unlet b:mdp_job
    endif
endfunction
" }}}
" Plugin Settings (for common plugins between vim and nvim)
" commentary {{{
if exists(":Commentary")
    nnoremap <leader>c <Plug>CommentaryLine
    onoremap <leader>c <Plug>Commentary
    xnoremap <leader>c <Plug>Commentary
endif
" }}}
" slime {{{
if exists(":SlimeSend")
    xmap <leader>s <Plug>SlimeSend
    nmap <leader>s <Plug>SlimeSend
endif
" }}}
" buftabline {{{
let g:buftabline_numbers = 2
let g:buftabline_indicators = 1
" }}}
" Vim Endwise {{{
" https://github.com/tpope/vim-endwise/issues/41#issuecomment-432905813
autocmd FileType tex
  \ let b:endwise_addition = '\="\\end" . matchstr(submatch(0), "{.\\{-}}")' |
  \ let b:endwise_words = 'begin' |
  \ let b:endwise_pattern = '\\begin{.\{-}}' |
  \ let b:endwise_syngroups = 'texSection,texBeginEnd,texBeginEndName,texStatement'
" }}}
" Gitgutter {{{
" the previous ~_ take two columns
let g:gitgutter_sign_modified_removed   = '^'
" update signs after focus
let g:gitgutter_terminal_reports_focus  = 0
let g:gitgutter_max_signs = 1000
hi GitGUtterAdd    ctermbg=none ctermfg=2
hi GitGUtterChange ctermbg=none ctermfg=3
hi GitGUtterDelete ctermbg=none ctermfg=1
" }}}
" vim-slime {{{
let g:slime_no_mappings = 1
" set config to use the pane on the right by default
let g:slime_default_config = {
    \ "socket_name": get(split($TMUX, ","), 0),
    \ "target_pane": "{right-of}"
    \ }
" vim terminal config
let g:slime_vimterminal_config = {
    \ "vertical": 1
    \ }
let g:slime_dont_ask_default = 0
" use temp file
let g:slime_paste_file = tempname()
" ipython specific setting
let g:slime_python_ipython = 0
" targets
if len($TMUX) != 0
    let g:slime_target = "tmux"
    let g:slime_dont_ask_default = 1
elseif match($TERM, "screen") != -1
    let g:slime_target = "screen"
else
    let g:slime_target = "vimterminal"
endif
" }}}
" tagbar {{{
let g:tagbar_compact = 1
let g:tagbar_indent = 1
let g:tagbar_left = 1
let g:tagbar_silent = 1
let g:tagbar_sort = 0
let g:tagbar_width = min([25, winwidth(0) / 4])
nnoremap <C-B> :Tagbar<CR>
" }}}
" vim:foldmethod=marker:foldlevel=0
