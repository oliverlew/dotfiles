" vim basic {{{
" be iMproved, put this line at TOP of vimrc
set nocompatible
let $VIM = $XDG_CONFIG_HOME.'/vim'
set packpath^=$VIM  " prepend my own vim directory
set runtimepath^=$VIM   " prepend my own vim directory
set backupdir=$XDG_CACHE_HOME/vim/backup
set directory=$XDG_CACHE_HOME/vim/swap
if !has('nvim')
    set viminfo+=n$XDG_CACHE_HOME/vim/viminfo
endif
" }}}
" Vim-Packager {{{
function! s:packager_init(packager) abort
  " Package manager
  call a:packager.add('kristijanhusak/vim-packager', {'type': 'opt'})
  " Basic
  call a:packager.add('tpope/vim-commentary')
  call a:packager.add('tpope/vim-endwise')
  call a:packager.add('tpope/vim-repeat')
  call a:packager.add('tpope/vim-sensible')
  call a:packager.add('tpope/vim-surround')
  call a:packager.add('ap/vim-buftabline')
  " Language server
  call a:packager.add('neovim/nvim-lspconfig', {'type': 'opt'})
  call a:packager.add('hrsh7th/cmp-nvim-lsp', {'type': 'opt'})
  call a:packager.add('hrsh7th/nvim-cmp', {'type': 'opt'})
  call a:packager.add('neoclide/coc.nvim', {'branch': 'release', 'type': 'opt'})
  call a:packager.add('prabirshrestha/vim-lsp', {'type': 'opt'})
  call a:packager.add('mattn/vim-lsp-settings', {'type': 'opt'})
  call a:packager.add('prabirshrestha/async.vim', {'type': 'opt'})
  call a:packager.add('prabirshrestha/asyncomplete.vim', {'type': 'opt'})
  call a:packager.add('prabirshrestha/asyncomplete-lsp.vim', {'type': 'opt'})
  call a:packager.add('natebosch/vim-lsc', {'type': 'opt'})
  " Enhancements
  " call a:packager.add('godlygeek/tabular')
  " call a:packager.add('junegunn/fzf')
  " call a:packager.add('junegunn/fzf.vim')
  " call a:packager.add('majutsushi/tagbar')
  " call a:packager.add('fs111/pydoc.vim')
  call a:packager.add('liuchengxu/vim-which-key')
  call a:packager.add('jpalardy/vim-slime')
  call a:packager.add('airblade/vim-gitgutter')
endfunction
function PackagerSetup(job, status)
    if a:status == 0 || a:status == 128
        packadd vim-packager
        call packager#setup(function('s:packager_init'))
    else
        echoerr "clone vim-packager timed out"
    endif
endfunction
let s:packager_dir = $VIM.'/pack/packager/opt/vim-packager'
let s:packager_git = 'https://github.com/kristijanhusak/vim-packager'
" running the git clone anyway, it won't do anything if exists
call job_start(['git', 'clone', s:packager_git, s:packager_dir], {
\   'exit_cb': function('PackagerSetup')
\ })
" }}}
" Vim Settings
" Vim Config {{{
" leader key, for key mappings
let mapleader = ','
let maplocalleader = '\'
" detect filetype and apply syntax highlighting
syntax on
filetype on
filetype plugin on
filetype indent on
set backup " create back files
set autoread " auto reload files
set autowrite " automatically write a file when leaving a buffer
set hidden
set encoding=utf-8
set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1
set spelllang=en,cjk " spell check but exclude CJK language
set clipboard=unnamedplus " use x11 normal clipboard
set timeoutlen=300 " time out for key code delays
set ttimeoutlen=0 " do not wait after escape key
set diffopt+=vertical " open diff window vertically
set nrformats+=alpha " use Ctrl-A/X to in/decrease alphabets
set completeopt=menu,preview,noinsert " completion
" }}}
" UI basic {{{
set guioptions=di       " gui options: dark, icon
set number              " show line number
set relativenumber      " show relative number
set showcmd             " shows what you are typing as a command
set wildmenu            " turn on wild menu on :e <Tab>
set title               " change the terminal's title
set showmatch           " show matching characters
set scrolloff=5         " minimum lines above and below cursor
set splitright          " split into right by default
set splitbelow          " split to below by default, better for ale's hover info
set updatetime=100      " update time, related to fugitive sign column update, etc.
set lazyredraw          " redraw when needed
set noerrorbells        " don't beep
set shortmess+=I        " don't show welcome screen
set showtabline=2       " show tabs on top
set laststatus=2        " show status line
set noshowmode          " do not show mode on the last line
set display+=lastline   " show partial line
set background=dark     " color scheme
set mouse=a             " enable mouse support in console
set fillchars+=vert:â”‚   " vertical split character
" mouse support for urxvt and st
if !has('nvim')
    if $TERM =~ "rxvt-unicode"
        set ttymouse=urxvt
    elseif $TERM == "st" || $TERM == "st-256color"
        set ttymouse=sgr
    endif
endif
" cursor shape for terminal emulators or linux console
if $TERM != "linux"
    let &t_SI = "\e[6 q"
    let &t_SR = "\e[4 q"
    let &t_EI = "\e[2 q"
else
    let &t_ve = "\e[?25h"
    let &t_vi = "\e[?25l"
    let &t_SI = "\e[?0c"
    let &t_SR = "\e[?4c"
    let &t_EI = "\e[?8c"
endif
" color scheme
colorscheme slate
hi SignColumn   ctermfg=0   ctermbg=None
hi CursorColumn ctermbg=8
hi Search       ctermfg=0   ctermbg=3
hi IncSearch    ctermfg=0   ctermbg=3
hi Folded       ctermfg=8   ctermbg=None
hi SpellBad     ctermfg=9   ctermbg=None
hi SpellCap     ctermfg=11  ctermbg=None
hi Visual       ctermbg=0   ctermbg=None cterm=reverse
hi StatusLine   ctermfg=7   ctermbg=None cterm=None
hi StatusLineNC ctermfg=7   ctermbg=None cterm=None
hi VertSplit    ctermfg=7   ctermbg=None cterm=None
" tabbufline styles are linked to built-in targets
hi PmenuSel     ctermfg=6   ctermbg=None cterm=None
hi TabLine      ctermfg=7   ctermbg=None cterm=None
hi TabLineSel   ctermfg=0   ctermbg=6    cterm=None
hi TabLineFill  ctermfg=7   ctermbg=None cterm=None
" incremental case-insensitive highlight smart case search
set incsearch ignorecase smartcase hlsearch
" built-in plugin or file type support
let g:termdebug_wide=1
let g:markdown_folding = 1
let g:markdown_fenced_languages = ['html', 'python', 'bash=sh', 'sh', 'c']
" }}}
" Space Tabs Indentations {{{
" indentations
set autoindent
set smartindent
set cindent
" tabs
set tabstop=4
set shiftwidth=0  " make it the same as tabstop
set softtabstop=-1  " make it the same as shiftwidth
set expandtab
set smarttab
" show tabs and trailing white space
set list
set listchars=tab:>-,trail:.
" }}}
" Navigations {{{
" go up/down
nnoremap <silent> j gj
nnoremap <silent> k gk
vnoremap <silent> j gj
vnoremap <silent> k gk
" buffers
nnoremap <silent> <C-K> :bprevious<CR>
nnoremap <silent> <C-J> :bnext<CR>
" toggle fold
nnoremap <space> za
" center the screen when searching
nnoremap n nzzzv
nnoremap N Nzzzv
" 
noremap <leader>q :q<CR>
noremap <leader>Q :qa<CR>
noremap <leader>d :bd<CR>
noremap <leader>w :w<CR>
noremap <leader>e :e<CR>
noremap <leader>x :x<CR>
noremap <leader>k :call ExecCurrentFile()<CR>
noremap <leader>. :let @/=""<CR>
noremap <leader>r :so $MYVIMRC<CR>
noremap <leader>z :call Goyo()<CR>
" }}}
" Autocmd {{{
augroup normal
    autocmd!
    autocmd VimEnter * normal! :startinsert :stopinsert
    autocmd BufNewFile,BufRead *.mac setlocal ft=maxima
    autocmd BufNewFile,BufRead *.plt setlocal ft=gnuplot
    autocmd BufNewFile,BufRead muttrc,*muttrc setlocal ft=neomuttrc
    autocmd BufWritePost *Xresources silent call system("DISPLAY=:0 xrdb -load ".expand('%'))
    autocmd FileType tex,markdown,mma setlocal sw=2 ts=2 sts=2 cole=0
    autocmd FileType tex,markdown,gitcommit setlocal spell
    autocmd FileType c,mma,json setlocal noet
    autocmd FileType markdown setlocal foldlevel=1
    autocmd FileType gnuplot setlocal commentstring=#%s
    autocmd FileType maxima setlocal commentstring=/*%s*/
    autocmd FileType mma setlocal commentstring=(*%s*)
    autocmd VimEnter * if &diff | execute 'windo set wrap' | endif
augroup END
augroup terminal_setup
    autocmd!
    tnoremap <C-\> <C-\><C-N>
    if has('nvim')
        autocmd TermOpen term://* setlocal nonu nornu signcolumn=no
        autocmd TermOpen term://* startinsert
        autocmd TermClose term://* call feedkeys("\<CR>")
    elseif exists("##TerminalOpen")
        autocmd TerminalOpen * setlocal nonu nornu signcolumn=no
    endif
augroup END
augroup latex
    autocmd!
    autocmd FileType tex ab tp textperiodcentered{}
    autocmd FileType tex ab te textellipsis{}
    autocmd FileType tex ab op originalpage{}<Left>
    " add normal font in math
    autocmd FileType tex xnoremap <localleader>n s\mathrm{}<Esc>P
    autocmd FileType tex nnoremap <localleader>n a\mathrm{}<Left>
    " add red color, or to existing text
    autocmd FileType tex xnoremap <localleader>m s{\color{red}}<Esc>P
    autocmd FileType tex nnoremap <localleader>m a{\color{red}}<Left>
    " remove red color depends on vim-surround
    autocmd FileType tex nnoremap <localleader>d F{mr%x`rd12l
augroup END
" autocmd FileType tex let b:ale_lsp_root='./'
" }}}
" IM Toggle {{{
" restore input method state when enter insert mode
let s:fcitx_cmd = "fcitx-remote"
function IMDisable()
    if !exists("s:hasfcitx")
        let s:hasfcitx = system(s:fcitx_cmd) =~# '^\d\n\+$'
    endif
    if s:hasfcitx
        let b:fcitx = system(s:fcitx_cmd)
        call system(s:fcitx_cmd . ' -c')
    endif
endfunction
function IMEnable()
    if exists('b:fcitx') && b:fcitx == 2
        call system(s:fcitx_cmd . ' -o')
    endif
endfunction
augroup im_toggle
    autocmd!
    autocmd InsertLeave * call IMDisable()
    autocmd InsertEnter * call IMEnable()
augroup END
" }}}
" Netrw -> NerdTree {{{
" Make Netrw function like NerdTree
let g:netrw_home         = $VIM " put temporary file there instead of $HOME
let g:netrw_banner       = 0    " disable banner (help message, etc. at top)
let g:netrw_browse_split = 4    " open file in previous (CTRL-W_p) window
let g:netrw_winsize      = -20  " split size, minus meaning absolute size
let g:netrw_dirhistmax   = 0    " disable history
let g:netrw_liststyle    = 0    " one file per line with nothing else
nnoremap <C-N> :Lexplore<CR>
" }}}
" My own goyo mode {{{
function Goyo()
    if exists("g:goyo_status")
        unlet g:goyo_status
        set nu rnu ru scl=auto stal=2 ls=2
    else
        let g:goyo_status = 1
        set nonu nornu noru scl=no stal=0 ls=0
    endif
endfunction
" }}}
" Execute current file {{{
function ShowOutput(channel, msg)
    if bufwinnr("exec_out") == -1
        sbuffer exec_out
    endif
endfunction

function AsyncRun(cmd)
    if bufexists("exec_out")
        call deletebufline("exec_out", 1, '$')
    endif
    call job_start(a:cmd, {
    \   "out_io": "buffer",
    \   "err_io": "buffer",
    \   "out_name": "exec_out",
    \   "err_name": "exec_out",
    \   "callback": function('ShowOutput'),
    \ })
endfunction

function ExecCurrentFile()
    if index(['gnuplot', 'perl', 'python', 'sh'], &ft) >= 0
        let command = [&ft, expand("%:p")]
    elseif &ft == "maxima"
        let command = ["maxima", "-b", expand("%:p")]
    elseif &ft == "tex"
        let command = ["latexmk", "-xelatex", "-pvc", expand("%:p")]
    else
        if &ft == "markdown"
            call MarkdownPreviewToggle()
        else
            echo "Not supported file type"
        endif
        return
    endif
    call AsyncRun(command)
endfunction

function Make()
    let makefile = findfile("Makefile", ".;")
    call AsyncRun(["make", "-C", makefile])
endfunction
" }}}
" statusline {{{
" update status on ALE status changes
augroup UpdateStatus
  autocmd!
  autocmd User ALEJobStarted redrawstatus
  autocmd User ALELintPost   redrawstatus
  autocmd User ALEFixPost    redrawstatus
  autocmd User lsp_diagnostics_updated redrawstatus
augroup END
function! ALEStatus()
    if get(g:, 'ale_enabled', 0) != 1
        return ''
    endif

    let l:ale_avail = get(g:, 'ale_enabled', 0) == 1
        \ && getbufvar(bufnr(''), 'ale_enabled', 1)
        \ && getbufvar(bufnr(''), 'ale_linted', 0) > 0
        \ && ale#engine#IsCheckingBuffer(bufnr('')) == 0
    let l:checking = ale#engine#IsCheckingBuffer(bufnr(''))
    let l:counts = ale#statusline#Count(bufnr(''))
    let l:all_errors = l:counts.error + l:counts.style_error
    let l:all_warnings = l:counts.warning + l:counts.style_warning

    if l:ale_avail == 0
        return ''
    elseif l:checking
        return ' ... '
    elseif l:counts.total == 0
        return ' OK '
    endif

    let l:ale_status = ' '
    let l:ale_status .= l:all_errors == 0 ? '' : printf('E:%2d ', l:all_errors)
    let l:ale_status .= l:all_warnings == 0 ? '' : printf('W:%2d ', l:all_warnings)
    let l:ale_status .= l:counts.info == 0 ? '' : printf('I:%2d ', l:counts.info)
    return l:ale_status
endfunction
function! VimLspStatus()
    let l:counts = lsp#get_buffer_diagnostics_counts()
    let l:lsp_status  = l:counts.error == 0 ? '' : printf('E:%2d ', l:counts.error)
    let l:lsp_status .= l:counts.warning == 0 ? '' : printf('W:%2d ', l:counts.warning)
    let l:lsp_status .= l:counts.information == 0 ? '' : printf('I:%2d ', l:counts.information)
    let l:lsp_status .= l:counts.hint == 0 ? '' : printf('H:%2d ', l:counts.hint)
    if l:lsp_status != ''
        return ' ' . l:lsp_status
    else
        return ''
    endif
endfunction
function! LSPStatus()
    if exists("g:ale_enabled") == 1
        return ALEStatus()
    elseif exists('*lsp#get_buffer_diagnostics_counts') == 1
        return VimLspStatus()
    else
        return ''
    endif
endfunction
function GitBranch()
    silent let l:githead = system('git -C '.expand("%:h:S").' branch --show-current')
    if v:shell_error != 0
        return ''
    else
        return trim(l:githead) . ' '
    endif
endfunction
hi User1 ctermbg=0
hi User2 ctermbg=8
let &stl  = '%#TabLineSel# %{mode()} %*'        " vim modes
let &stl .= '%2*%( %{GitBranch()}%(%r%h %)%)'   " git branch, readonly, help
let &stl .= '%1*%< %t %m %w '                   " file name, modified, preview
let &stl .= '%='                                " split left and right
let &stl .= '%{&ff} %(| %{&fenc} %)%(| %y %)'   " format, encoding and type of the file
let &stl .= '%2* %3p%% | %3l:%3c '              " cursor location
let &stl .= '%#TabLineSel#%{LSPStatus()}%*'     " lsp status
" }}}
" Git {{{
" show the log in a pretty way
function! GitLog()
    silent !git log --all --decorate --oneline --graph --date-order
    redraw!
endfunction
function! GitTig()
    silent !tig -C "$(dirname "$(realpath "%")")"
    redraw!
endfunction
" key bindings
nnoremap <leader>gg :call GitTig()<CR>
nnoremap <leader>gl :call GitLog()<CR>
" }}}
" Markdown preview{{{
function MarkdownPreviewToggle()
    if !exists('b:mdp_job')
        let b:mdp_job = job_start(['grip', '-b', expand("%:p")])
    else
        call job_stop(b:mdp_job)
        unlet b:mdp_job
    endif
endfunction
" }}}
" Plugin Settings
" buftabline {{{
let g:buftabline_numbers = 2
let g:buftabline_indicators = 1
" }}}
" Vim Which Key {{{
let g:which_key_group_dicts = ''
let g:which_key_centered = 0
let g:which_key_hspace = 2
let g:which_key_use_floating_win = 0
let g:which_key_fallback_to_native_key = 1
let g:which_key_map = {
  \ 'q' : 'quit',
  \ 'Q' : 'quit all',
  \ 'd' : 'close buffer',
  \ 'w' : 'save',
  \ 'e' : 'edit (reload)',
  \ 'x' : 'save and quit',
  \ 'k' : 'run current file',
  \ '.' : 'clear search hl',
  \ 'z' : 'Goyo mode',
  \ 's' : 'slime',
  \ 'c' : 'comment',
  \ 'a' : { 'name' : '+ale' },
  \ 'g' : {
    \ 'name' : '+git-operation',
    \ 't' : { 'name' : '+stash' },
    \ },
  \ }
let g:which_key_map_local = {
  \ 'l' : { 'name' : '+vimtex' },
  \ }
nnoremap <silent> <leader> :WhichKey '<leader>'<CR>
vnoremap <silent> <leader> :WhichKeyVisual '<leader>'<CR>
nnoremap <silent> <localleader> :WhichKey '<localleader>'<CR>
vnoremap <silent> <localleader> :WhichKeyVisual '<localleader>'<CR>
function WhichKeyRegister()
    if &rtp =~ "vim-which-key"
        call which_key#register('<leader>', 'g:which_key_map')
        call which_key#register('<localleader>', 'g:which_key_map_local')
    endif
endfunction
autocmd VimEnter * call WhichKeyRegister()
" }}}
" Vim commentary {{{
nmap <leader>c <Plug>CommentaryLine
omap <leader>c <Plug>Commentary
xmap <leader>c <Plug>Commentary
" }}}
" Vim Endwise {{{
" https://github.com/tpope/vim-endwise/issues/41#issuecomment-432905813
autocmd FileType tex
  \ let b:endwise_addition = '\="\\end" . matchstr(submatch(0), "{.\\{-}}")' |
  \ let b:endwise_words = 'begin' |
  \ let b:endwise_pattern = '\\begin{.\{-}}' |
  \ let b:endwise_syngroups = 'texSection,texBeginEnd,texBeginEndName,texStatement'
" }}}
" Gitgutter {{{
" the previous ~_ take two columns
let g:gitgutter_sign_modified_removed   = '^'
" update signs after focus
let g:gitgutter_terminal_reports_focus  = 0
let g:gitgutter_max_signs = 1000
" }}}
" Mathematica {{{
let g:mma_candy = 2
" }}}
" " CoC {{{
" let g:coc_config_home = $VIM
" " }}}
" vim-slime {{{
let g:slime_no_mappings = 1
xmap <leader>s <Plug>SlimeRegionSend
nmap <leader>s <Plug>SlimeParagraphSend
" set config to use the pane on the right by default
let g:slime_default_config = {
    \ "socket_name": get(split($TMUX, ","), 0),
    \ "target_pane": "{right-of}"
    \ }
" vim terminal config
let g:slime_vimterminal_config = {
    \ "vertical": 1
    \ }
let g:slime_dont_ask_default = 0
" use temp file
let g:slime_paste_file = tempname()
" ipython specific setting
let g:slime_python_ipython = 0
" targets
if len($TMUX) != 0
    let g:slime_target = "tmux"
    let g:slime_dont_ask_default = 1
elseif match($TERM, "screen") != -1
    let g:slime_target = "screen"
else
    let g:slime_target = "vimterminal"
endif
" }}}
" LSP {{{
if has('nvim')
    packadd nvim-lspconfig
    packadd cmp-nvim-lsp
    packadd nvim-cmp
    lua << EOF
    local cmp = require('cmp')
    cmp.setup({
        sources = cmp.config.sources({
            { name = 'nvim-lsp' },
            { name = 'buffer' }
        })
    })
    cmp.setup.cmdline('/', { sources = { { name = 'buffer' } } })
    cmp.setup.cmdline(':', {
        sources = cmp.config.sources(
            { { name = 'path' } },
            { { name = 'cmdline' } }
        )
    })
    local cap = vim.lsp.protocol.make_client_capabilities()
    cap = require('cmp_nvim_lsp').update_capabilities(cap)
    require('lspconfig').pylsp.setup({ capabilities = cap })
    require('lspconfig').bashls.setup({ capabilities = cap })
EOF
else
    " packadd coc.nvim
    " packadd vim-lsc
    packadd vim-lsp
    packadd vim-lsp-settings
    packadd async.vim
    packadd asyncomplete.vim
    packadd asyncomplete-lsp.vim
endif
" }}}
" vim-lsp {{{
let g:which_key_map.l = { "name": "language server" }
let g:lsp_diagnostics_signs_delay = 200
let g:lsp_diagnostics_echo_delay = 200
let g:lsp_diagnostics_highlights_delay = 200
let g:lsp_diagnostics_echo_cursor = 1
autocmd User lsp_buffer_enabled setlocal omnifunc=lsp#complete
" }}}
" vim-lsc {{{
let g:lsc_auto_completeopt = 'popup,noinsert,menu,noselect'
let g:lsc_server_commands = {
  \     'python': {
  \         'command': 'pylsp',
  \         'log_level': -1,
  \         'workspace_config': {
  \             'pylsp.configurationSources': ['pycodestyle'],
  \             'pylsp.plugins.yapf.enabled': v:false,
  \         }
  \     },
  \     'sh': 'bash-language-server start',
  \     'vim': 'vim-language-server --stdio',
  \     'json': 'vscode-json-languageserver --stdio',
  \     'lua': 'lua-language-server',
  \     'tex': {
  \         'command': 'texlab',
  \         'workspace_config': {
  \             "latex.build.args": ["-xelatex", "-synctex=1", "%f"],
  \         }
  \     }
  \ }
" }}}
" asyncomplete {{{
inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
let g:asyncomplete_auto_popup = 1
let g:asyncomplete_auto_completeopt = 0
" }}}
" tagbar {{{
let g:tagbar_width = max([25, winwidth(0) / 5])
let g:tagbar_compact = 1
let g:tagbar_sort = 0
nnoremap <C-B> :Tagbar<CR>
" }}}
" vim:foldmethod=marker:foldlevel=0
