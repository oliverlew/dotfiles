#!/usr/bin/env python3
# Reference: https://www.ietf.org/rfc/rfc5092.txt
# Reference: https://www.ietf.org/rfc/rfc3501.txt
import imaplib
import argparse
import email.utils
import email.header
from subprocess import run, PIPE


def get_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument('email')
    parser.add_argument('-s', '--server')
    parser.add_argument('-p', '--port', default=imaplib.IMAP4_SSL_PORT)
    parser.add_argument('-P', '--password')
    parser.add_argument('-n', '--download', type=int)
    return parser


def check_email(email):
    if '@' not in email:
        print(f"Email address not corrent: {email}")
        exit(1)


def get_server(email):
    special_servers = {'smail.nju.edu.cn': 'imap.exmail.qq.com'}
    domain = email.split('@')[1]
    return special_servers.get(domain, f'imap.{domain}')


def get_password(email):
    res = run(['pass', 'show', f'mail/{email}'], stdout=PIPE, stderr=PIPE)
    if res.returncode == 0:
        return res.stdout.decode().strip()
    else:
        print(res.stderr.decode()).strip()
        exit(1)


def get_args():
    args = get_parser().parse_args()
    check_email(args.email)
    if args.server is None:
        args.server = get_server(args.email)
    if args.password is None:
        args.password = get_password(args.email)
    return args


def netease_workaround():
    # reference: https://blog.csdn.net/jony_online/article/details/108638571
    imaplib.Commands['ID'] = ('AUTH')
    m._simple_command('ID', '("name" "IMAPClient")')


def decode_header(hdr):
    # https://www.ietf.org/rfc/rfc2047.txt section 4
    if hdr is None:
        return hdr
    msg, encoding = email.header.decode_header(hdr)[0]
    if encoding is not None:
        msg = msg.decode(encoding)
    return msg


def envelope_info(msg):
    # reference: https://www.ietf.org/rfc/rfc3501.txt section 7.4.2
    # every msg is an ENVELOPE structure: UID (ENVELOPE (...))
    msg = msg.decode()

    # strip the outside two pairs of parenthesis, only remain "..."
    left = msg.index('(', msg.index('(') + 1)
    right = msg.rindex(')', 0, msg.rindex(')'))
    envelope = msg[left + 1: right]

    # convert to tuple or list format, and evaluate
    envelope = envelope.replace('NIL', 'None,')
    envelope = envelope.replace('" ', '", ')
    envelope = envelope.replace(') ', '), ')
    date, subject, (name, _, mail, host) = eval(envelope)[:3]

    # export
    date = email.utils.parsedate_to_datetime(decode_header(date))
    # date = email.utils.parsedate_tz(decode_header(date))
    subject = decode_header(subject)
    name = decode_header(name)
    mail = "{}@{}".format(decode_header(mail), decode_header(host))
    return date, subject, name, mail


args = get_args()

m = imaplib.IMAP4_SSL(args.server, args.port, timeout=10)
m.login(args.email, args.password)
netease_workaround()  # special care for netease email
m.select()
uids = m.search(None, 'UNSEEN')[1][0].decode().split()
print(len(uids))
if args.download and len(uids[-args.download:]) > 0:
    for msg in m.fetch(','.join(uids[-args.download:]), '(ENVELOPE)')[1]:
        date, subject, name, mail = envelope_info(msg)
        date = date.astimezone().strftime("%Y-%m-%d %H:%M:%S %a")
        print(f"\nDate: {date}\nSubjecct: {subject}\nFrom: {name}<{mail}>")
m.close()
m.logout()
